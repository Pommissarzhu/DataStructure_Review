在作进栈运算时,应先判别栈是否(  **满**  ),在作退栈运算时应先判别栈是否( **空**   )。当栈中元素为n个,作进栈运算时发生上溢,则说明该栈的最大容量为(  **n**  )。

为了增加内存空间的利用率和减少溢出的可能性,由两个栈共享一片连续的内存空间时,应将两栈的 ( **栈底**   )分别设在这片内存空间的两端,这样,当(  **两个栈均不空,且一个栈的栈顶到达另一个栈的栈底.**  )时，才产生上溢。

 一个栈的输入序列为123…n，若输出序列的第一个元素是n，输出第i（1<=i<=n）个元素是 **n-i+1**

栈在（ **A. 递归调用        B. 子程序调用       C. 表达式求值**   ）中应用

一个递归算法必须包括 **终止条件和递归部分**




中缀表达式转后缀的超快的方法：

首先按照运算的先后顺序将表达式全部都添加上括号

从里到外将所有运算符都拿到右括号的右边

最后再将所有括号都去掉

巨他妈快

比如 (a+b)*c*(d-e/f)

化成(((a+b)*c)*((d-(e/f))))

接着(((ab)+c)*((d(ef)/)-))* 

最后ab+c*def/-* 



设计一个判别表达式中左，右括号是否配对出现的算法，采用（  **栈**）数据结构最佳。 



表达式3* 2^(4+2*2-6*3)-5求值过程中当扫描到6时，对象栈和算符栈为（ ），其中^为乘幂 。

A. 3,2,4,1,1；(*^(+*-     B. 3,2,8；(*^-    C. 3,2,4,2,2；(*^(-      **D. 3,2,8；(*^(-**



用链接方式存储的队列，在进行删除运算时 **头、尾指针可能都要修改**



假设以数组A[m]存放 **循环队列** 的元素,其头尾指针分别为front和rear，则当前队列中的**元素个数**为 $(rear-front+m)\mod m$

循环队列存储在数组A[0..m]中，则入队时的操作为 ==rear=(rear+1)%(m+1)**==

若用一个大小为6的数组来实现循环队列，且当前rear和front的值分别为0和3，当从队列中删除一个元素，再加入两个元素后，rear和front的值分别为多少？ **2和4**

`删除元素front+1,添加元素rear+1`



